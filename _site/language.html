<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>The GraphIt Programming Language</title>
    
    <link rel="stylesheet" href="stylesheets/styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="stylesheets/prism.css" />
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-40269412-1']);
      _gaq.push(['_setDomainName', 'simit-lang.org']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <a href="index"><h1 class="title"> GraphIt</h1></a>
        <p>A high-performance graph domain specific language</p>
        <ul>
          <li><a href="http://github.com/yunmingzhang17/graphit">View On <strong>GitHub</strong></a></li>
        </ul>
	<p><a href="index">About</a></p>
        <p><a href="getting-started">Getting Started</a></p>
        <p><a href="language">Language Manual</a></p>
        <p><a href="publications">Publications</a></p>
	<p><a href="https://lists.csail.mit.edu/mailman/listinfo/graphit">Mailing List</a></p>
      </header>
      <footer>
        <p><a href="https://yunmingzhang.wordpress.com/">Yunming Zhang</a> <br>yunming at mit dot edu</p>
        <p><small>Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
      <section class="language-graphit">
      <h1 id="the-graphit-programming-language">The GraphIt Programming Language</h1>

<p class="no_toc">This guide introduces GraphIt language features and shows how they can be used in programs.</p>

<ul id="markdown-toc">
  <li><a href="#the-graphit-programming-language" id="markdown-toc-the-graphit-programming-language">The GraphIt Programming Language</a></li>
  <li><a href="#basics" id="markdown-toc-basics">Basics</a>    <ul>
      <li><a href="#functions" id="markdown-toc-functions">Functions</a></li>
      <li><a href="#variables" id="markdown-toc-variables">Variables</a></li>
      <li><a href="#comments" id="markdown-toc-comments">Comments</a></li>
    </ul>
  </li>
  <li><a href="#control-flow-statements" id="markdown-toc-control-flow-statements">Control Flow Statements</a>    <ul>
      <li><a href="#if-statements" id="markdown-toc-if-statements">If Statements</a></li>
      <li><a href="#while-loops" id="markdown-toc-while-loops">While Loops</a></li>
      <li><a href="#for-loops" id="markdown-toc-for-loops">For Loops</a></li>
    </ul>
  </li>
  <li><a href="#elements-vectors-vertexsets-edgesets" id="markdown-toc-elements-vectors-vertexsets-edgesets">Elements, Vectors, VertexSets, EdgeSets</a>    <ul>
      <li><a href="#elements" id="markdown-toc-elements">Elements</a></li>
      <li><a href="#vectors" id="markdown-toc-vectors">Vectors</a></li>
      <li><a href="#edgesets" id="markdown-toc-edgesets">Edgesets</a></li>
      <li><a href="#vertexsets" id="markdown-toc-vertexsets">Vertexsets</a></li>
    </ul>
  </li>
  <li><a href="#set-opeartors" id="markdown-toc-set-opeartors">Set Opeartors</a>    <ul>
      <li><a href="#edgeset-operators" id="markdown-toc-edgeset-operators">Edgeset Operators</a>        <ul>
          <li><a href="#from-to-and-filter" id="markdown-toc-from-to-and-filter">from, to and filter</a></li>
          <li><a href="#srcfilter-and-dstfilter" id="markdown-toc-srcfilter-and-dstfilter">srcFilter and dstFilter</a></li>
          <li><a href="#apply" id="markdown-toc-apply">apply</a></li>
          <li><a href="#applymodified" id="markdown-toc-applymodified">applyModified</a></li>
          <li><a href="#combining-edgeset-operators" id="markdown-toc-combining-edgeset-operators">combining edgeset operators</a></li>
        </ul>
      </li>
      <li><a href="#vertexset-operators" id="markdown-toc-vertexset-operators">Vertexset Operators</a>        <ul>
          <li><a href="#filter" id="markdown-toc-filter">filter</a></li>
          <li><a href="#apply-1" id="markdown-toc-apply-1">apply</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#extern-functions" id="markdown-toc-extern-functions">Extern Functions</a></li>
  <li><a href="#export-functions" id="markdown-toc-export-functions">Export Functions</a></li>
  <li><a href="#library-rountines" id="markdown-toc-library-rountines">Library Rountines</a></li>
  <li><a href="#scheduling-language" id="markdown-toc-scheduling-language">Scheduling Language</a></li>
  <li><a href="#python-binding" id="markdown-toc-python-binding">Python Binding</a>    <ul>
      <li><a href="#graphit-language-extensions" id="markdown-toc-graphit-language-extensions">GraphIt language extensions</a></li>
      <li><a href="#type-mappings" id="markdown-toc-type-mappings">Type mappings</a>        <ul>
          <li><a href="#scalar-types-mappings" id="markdown-toc-scalar-types-mappings">Scalar types mappings</a></li>
          <li><a href="#non-scalar-types-mappings" id="markdown-toc-non-scalar-types-mappings">Non-scalar types mappings</a></li>
        </ul>
      </li>
      <li><a href="#python-module-api" id="markdown-toc-python-module-api">Python module API</a>        <ul>
          <li><a href="#graphitgraphit_module" id="markdown-toc-graphitgraphit_module"><code class="highlighter-rouge">graphit.graphit_module</code></a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="basics">Basics</h1>
<p>GraphIt is an imperative language with statements, control flow, and high-level operators on sts of vertices ane edges. In this section, we describe some of the language’s basic constructs.</p>

<h2 id="functions">Functions</h2>
<p>Functions can take any number of parameters, including none. Each parameter
must be declared with its name followed by its type (separated by a <code class="highlighter-rouge">:</code>). In
the following example, the function <code class="highlighter-rouge">add</code> takes two parameters named <code class="highlighter-rouge">a</code> and
<code class="highlighter-rouge">b</code>, both of which are of type <code class="highlighter-rouge">float</code>, and returns a single result (named <code class="highlighter-rouge">c</code>)
that is also a <code class="highlighter-rouge">float</code>. The function result is separated from the list of
parameters by a <code class="highlighter-rouge">-&gt;</code> and the function declaration is delimited by the <code class="highlighter-rouge">end</code>
keyword.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func add(a : float, b : float) -&gt; c : float
  c = a + b;
end
</code></pre></div></div>

<p>Like functions in MATLAB, GraphIt functions can return any number of results,
including none. In the next example, the function <code class="highlighter-rouge">minMax</code> takes two <code class="highlighter-rouge">float</code>
parameters and return two <code class="highlighter-rouge">float</code> results: the smaller of the two inputs as the
first result and the larger of the two inputs as the second result.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func minMax(a : float, b : float) 
    -&gt; (c : float, d : float)
  if a &lt; b
    c = a;
    d = b;
  else
    c = b;
    d = a;
  end
end
</code></pre></div></div>

<p>Note that the list of function results must be surrounded by parentheses if the
function returns more than one result. (The parentheses are optional if the
function returns just a single result.)</p>

<h2 id="variables">Variables</h2>
<p>Variables are declared in function bodies or in the global scope using the
<code class="highlighter-rouge">var</code> keyword. The following example declares an integer variable named <code class="highlighter-rouge">foo</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo : int;
</code></pre></div></div>

<p>The variable can be initialized with the following syntax.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var foo : float = 0.0;
</code></pre></div></div>

<p>The <code class="highlighter-rouge">const</code> keyword creates a variable that cannot be modified after
initialization.  Individual elements of const vectors can still be updated.</p>

<h2 id="comments">Comments</h2>
<p>Single-line comments start with <code class="highlighter-rouge">%</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h = 0.01;  % h is the time-step size.
</code></pre></div></div>

<p>Multi-line comments are surrounded by <code class="highlighter-rouge">%{</code> and <code class="highlighter-rouge">%}</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>%{
h is the time-step size.
h is initialized to one millisecond.
%}
h = 0.001;
</code></pre></div></div>

<h1 id="control-flow-statements">Control Flow Statements</h1>
<p>GraphIt supports a variety of control flow constructs, including <code class="highlighter-rouge">if</code> statements,
<code class="highlighter-rouge">while</code> loops, <code class="highlighter-rouge">do</code>-<code class="highlighter-rouge">while</code> loops and <code class="highlighter-rouge">for</code> loops.</p>

<h2 id="if-statements">If Statements</h2>

<p>In GraphIt, a simple <code class="highlighter-rouge">if</code> statement looks something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &lt; 1
  print "x is less than 1";
end
</code></pre></div></div>

<p>An <code class="highlighter-rouge">if</code> statement can optionally include an <code class="highlighter-rouge">else</code> clause as well as an any
number of <code class="highlighter-rouge">elif</code> (else-if) clauses:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x &lt; 1
  print "x is less than 1";
elif x &gt; 5
  print "x is greater than 5";
else
  print "x is between 1 and 5";
end
</code></pre></div></div>

<h2 id="while-loops">While Loops</h2>

<p>A <code class="highlighter-rouge">while</code> loop in GraphIt looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while x &lt; 100
  x = 2 * x;
end
</code></pre></div></div>

<p>As with <code class="highlighter-rouge">if</code> statements, logical operators and comparison operators can be used
to construct more complex conditions. Note that if the condition of a <code class="highlighter-rouge">while</code>
loop is false when a GraphIt program first encounters the loop, the loop body
will not be executed at all.</p>

<h2 id="for-loops">For Loops</h2>

<p>GraphIt <code class="highlighter-rouge">for</code> loops are more like those found in MATLAB, Julia and Python than
those available in C. You can use a <code class="highlighter-rouge">for</code> loop to iterate over the set of all integers between two values, as shown in the following example.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i in 0:10
  print i;
end
</code></pre></div></div>

<p>Note that the lower bound is <em>inclusive</em> while the upper bound is <em>exclusive</em>
(like Python), so the above example prints all integers between 0 and 9 but
omits 10.</p>

<h1 id="elements-vectors-vertexsets-edgesets">Elements, Vectors, VertexSets, EdgeSets</h1>
<p>Elements, vertexsets, edgesets and vectors form GraphIt’s <em>data model</em>.</p>

<h2 id="elements">Elements</h2>
<p>An element is a type that stores one or more data fields, much like a struct in
C/C++. For example, a vertex in a social network representing a person can have a Person Element type. In the future, we plan to support fields in the Element. Currently, fields associated with an Element are expressed as separate Vectors descrived below.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>element Person
end
</code></pre></div></div>

<h2 id="vectors">Vectors</h2>

<p>Vectors are associated with an element. Essentially they act as fields of the elements. The following code says that <code class="highlighter-rouge">age</code> is a vector for <code class="highlighter-rouge">Person</code> Element type. Each Person would have an associated age field, and the field is initialized to 0.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const age : vector {Person}(int) = 0;

</code></pre></div></div>

<h2 id="edgesets">Edgesets</h2>
<p>Edgesets are have connectivity information. In particular, edge
set definitions specify the type of elements from which each edge’s endpoints come.
The following declares a set of spring elements that each connect two points
from the <code class="highlighter-rouge">edges</code> set:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Follow}(Person,Person);
</code></pre></div></div>

<p>There is no explicit graph type in GraphIt; rather, graphs are formed implicitly
from the edgesets. This is similar to how graphs are
often defined in mathematical papers (i.e. as an ordered pair <code class="highlighter-rouge">G = (V,E)</code>).</p>

<h2 id="vertexsets">Vertexsets</h2>

<p>Vertexsets are sets of vertices of a specific Element Type. <code class="highlighter-rouge">people</code> is a vertexset made up of endpoint elements of Person Type from the <code class="highlighter-rouge">edges</code> edgeset.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const people : vertexset{Person} = edges.getVertices();

</code></pre></div></div>

<h1 id="set-opeartors">Set Opeartors</h1>
<h2 id="edgeset-operators">Edgeset Operators</h2>

<h3 id="from-to-and-filter">from, to and filter</h3>
<p><code class="highlighter-rouge">from</code> and <code class="highlighter-rouge">to</code> Filters out edges whose source vertex is in the input set.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const people_age_over_40 : vertexset{Person} = ... 
const people_age_over_60 : vertexset{Person} = ...

func main()
  ...
  % find edges between people over 40 years old to people over 60 years old
  var filtered_edges : edgeset{Friend}(Person, Person} = 
       friend_edges.from(people_age_over_40).to(people_age_over_60);
end 

</code></pre></div></div>

<p><code class="highlighter-rouge">filter</code> simply supplies a boolean function that checks every edge.</p>

<h3 id="srcfilter-and-dstfilter">srcFilter and dstFilter</h3>

<p><code class="highlighter-rouge">srcFilter</code> and <code class="highlighter-rouge">dstFilter</code> filters out edges where the input boolean filtering function <code class="highlighter-rouge">filter_func</code> returns true.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func filter_func(v : Vertex) -&gt; output : bool
    output =  age[v] &gt; 40;
end

func main()
  ...
  filtered_edges = edges.srcFilter(filter_func);
  ...
end

</code></pre></div></div>

<h3 id="apply">apply</h3>

<p>This operator applies a function <code class="highlighter-rouge">updateEdge </code> to every edge. In one iteration of PageRank,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func updateEdge(src : Vertex, dst : Vertex)
    new_rank[dst] += contrib[src];
end

func main()
  ...
  edges.apply(updateEdge);
  ...
end
</code></pre></div></div>

<h3 id="applymodified">applyModified</h3>
<p>This operator applies a function (<code class="highlighter-rouge">updateEdge</code>) to every edge. Returns a vertexset that contains destination vertices whose entry in the vector has been modified in <code class="highlighter-rouge">updateEdge</code>. The programmer can optionally disable deduplication within modfieid vertices. Deduplication is enabled by default.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func updateEdge(src : Vertex, dst : Vertex)
    parent[dst] = src;
end

func main()
  ...
  edges.applyModified(updateEdge,parent, true);
  ...
end

</code></pre></div></div>

<h3 id="combining-edgeset-operators">combining edgeset operators</h3>

<p>The various operators can be and often are chained together.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>frontier = edges.from(frontier).to(toFilter).applyModified(updateEdge,parent, true);

</code></pre></div></div>

<h2 id="vertexset-operators">Vertexset Operators</h2>

<h3 id="filter">filter</h3>
<p>The filter operator is similar to the edgeset filter, except for it is applied on a single vertex and not edge.</p>

<h3 id="apply-1">apply</h3>
<p>The apply operator is similar to the edgeset apply operator, but applied to a vertex.</p>

<h1 id="extern-functions">Extern Functions</h1>

<p>The users can call functions implemented in C++ from GraphIt. These can be used in cases where the user needs some external functionalities that are not currently supported in the GraphIt language. For example, certain solvers or more complex operations that are not necessarily related to graphs. Another example could be a distance estimator used in AStar search.</p>

<p>The user needs to define a prototype of the function in the GraphIt program with the <code class="highlighter-rouge">extern</code> keyworkd. The example below defined a extern function named <code class="highlighter-rouge">extern_func</code> that takes as input a vertex and outputs a double.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern func extern_func(v: Vertex) -&gt; output:double; 
</code></pre></div></div>

<p>The users can use the extern function inside any function and it can be supplied as arguments to vertexset and edgeset operators. For exmaple, the extern_func can be supplied to the apply operator on a vertexset.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vertexset.apply(extern_func);
</code></pre></div></div>

<p>The users can also use vectors defined in the original GraphIt program inside the extern function. In the C++ definition of the extern programs, the user simply needs to declare an extern variable. The following example shows the definition of an extern function that reads a graphit_vector that is defined in the GraphIt program, and adds the value one to the vector for vertex v.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>extern double * graphit_vector;

double extern_func(v: NodeID){
  return graphit_vector[v] + 1;
}
</code></pre></div></div>

<p>To compile GraphIt programs, the user will first need to generate the C++ program with the GraphIt compiler. And later compile the generated file along with the other C++ file with the extern function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python graphitc.py -f graphit_file.gt -o graphit_generated.cpp 
g++ -std=c++11 -O3 -g -I ../../src/runtime_lib/ graphit_generated.cpp extern_func.cpp -o executable 
</code></pre></div></div>

<h1 id="export-functions">Export Functions</h1>

<p>The GraphIt compiler generate a stand alone executable with a main function by default. However, the user can also generate a library version of the function that can be used in the Python binding or just a regular C++ function using the export functions.</p>

<p>To declare an export function, the user simply uses the <code class="highlighter-rouge">export</code> keyword before the function that is going to be exported. The following example shows the definition of an export function <code class="highlighter-rouge">export_func</code> that takes as input a graph named <code class="highlighter-rouge">input_edges</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export func export_func(input_edges : edgeset{Edge}(Vertex,Vertex))
  ...
end
</code></pre></div></div>

<p>If the graph is passed in as argument to the exported function, then the vertexsets and vectors cannot be initialized in the const declarations. This is because the size of the vertexset and edgesets are not known at compile time. In this case, the user would need to manually initialize vertexsets and vectors. If the graph is not loaded in as an argument to the export function, then the user can continue to load the graph, initialize the vertexsets and vectors in const declarations.</p>

<p>Here we show an example to initilize the vertexsets and vectors when the graph is an input argument to the <code class="highlighter-rouge">export_func</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Edge}(Vertex,Vertex);
const vertices : vertexset{Vertex};
const float_vector : vector{Vertex}(float);

func initVector(v : Vertex)
     float_vector[v] = 0.0;
end

export func export_func(input_edges : edgeset{Edge}(Vertex,Vertex))
  edges = input_edges;
  vertices = edges.getVertices();
  float_vector = new vector{Vertex}(float)();
  vertices.apply(initVector);
end

</code></pre></div></div>

<h1 id="library-rountines">Library Rountines</h1>

<ul>
  <li><strong>getRandomOutNgh(v: Vertex)</strong>: Returns a random outgoing neighbor of the Vertex v.</li>
  <li><strong>getRandomInNgh(v: Vertex)</strong>: Returns a random incoming neighbor of the Vertex v.</li>
  <li><strong>serialMinimumSpanningTree(graph : edgeset{Vertex, Vertex, int}, start_vertex : Vertex)</strong>: This operator computes a serial Minimum Spanning Tree computation on the weighted graph <code class="highlighter-rouge">graph</code> from the <code class="highlighter-rouge">start_vertex</code>. It returns a vector of VertexIDs (integers). This vector contains the parent VertexID for each Vertex v.</li>
</ul>

<h1 id="scheduling-language">Scheduling Language</h1>

<p>In this section, we provide some heuristics for tuning the schedules for improved performance. The scheduling language specified separately can tune the performance of the algorithm. The example below first described the algorithm with edgeset, vertexset, and the <code class="highlighter-rouge">main</code> function. The user can then use the <code class="highlighter-rouge">schedule:</code> keyword to mark the beginning of schedule spcification.</p>

<p>The label <code class="highlighter-rouge">#s1#</code> is used in the scheduling commands to identify the apply operator the schedule is applied on. The label <code class="highlighter-rouge">#s1</code> must be specified before the edgeset apply operator if the user intend to tune the performance of the operator.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const edges : edgeset{Edge}(Vertex,Vertex);
const vertices : vertexset{Vertex};
const float_vector : vector{Vertex}(float);
...

func main ()
  ...
  #s1# edges.apply(updateEdge);
  ...
end

schedule:
  program-&gt;configApplyDirection("s1", "DensePull");
  ...

</code></pre></div></div>

<p>The full set of schedules are listed in the table below. We refer users to the Section 5 of the <a href="https://arxiv.org/abs/1805.00923">arxiv report</a> for details of scheduling language.</p>

<p><img src="gallery/SchedulingApply.png" alt="Scheduling Functions" /></p>

<p>Here are some general guidelines for selecting a set of schedules</p>

<ul>
  <li><strong>Step 1:</strong> Select a direction from SparsePush, DensePush, DensePull, SparsePush-DensePull with <code class="highlighter-rouge">configApplyDirection</code>. For large social networks that uses a frontier, SparsePush-DensePull is usually a good choice. For PageRank, DensePull is always the best. For road networks, SparsePush often is the best.</li>
  <li><strong>Step 2:</strong> Select a parallelization strategy with <code class="highlighter-rouge">configApplyParallelization</code>. Usually dynamic-vertex-parallel is the best. For road networks, it might better to switch to static-vertex-parallel. Edge-aware-dynamic-vertex-parallel is only better for PageRank and Collaborative Filtering in some cases.</li>
  <li><strong>Step 3:</strong> Select a layout for Dense Vertex Set with <code class="highlighter-rouge">configApplyDenseVertexset</code>. if a DensePull direction is used, then you can potentially to use bitvector for the vertexset when the graph has a large number of vertices (currently only working for the pull direction).</li>
  <li><strong>Step 4:</strong> If a DensePull direction is used, then you can use <code class="highlighter-rouge">configNumSSG</code> (currently only working for the pull direction) to partition the graph for cache efficiency. This is mostly useful for applications that spend a large amount of time processing all the edges (PageRank, PageRankDelta, and Collaborative Filtering). This optimization is usually hurtful for application that only touch a subset of vertices (BFS, SSSP, BC).  Calculations for the number of segments is based on the last level cache (LLC) size.</li>
  <li><strong>Step 5:</strong> <code class="highlighter-rouge">fuseFields</code> fuses fields that are accessed together into array of structurs to reduce the number of random accesses. Only needed for PageRankDelta so far.</li>
</ul>

<p>Some existing schedules 
There are many predfined schedules in the <a href="https://github.com/GraphIt-DSL/graphit/tree/master/test/input_with_schedules"><strong>input_with_schedules</strong> directory</a>. 
For a specific graph and application, the <a href="https://github.com/GraphIt-DSL/graphit/blob/master/graphit_eval/eval/table7/benchmark.py#L16">script</a> shows the best schedule.</p>

<p>In general, the following schedule achieves reasonable perforamnce on social networks (assuming the relevant edgeset apply operator is labeled with <code class="highlighter-rouge">#s1</code>).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schedule:
    program-&gt;configApplyDirection("s1","SparsePush-DensePull");
    program-&gt;configApplyParallelization("s1", "dynamic-vertex-parallel");
</code></pre></div></div>

<h1 id="python-binding">Python Binding</h1>

<p>GraphIt provides bindings for the user to load and call GraphIt functions in python. The algorithm with it’s schedule can be written in a GraphIt file which can then be compiled and loaded using the GraphIt python module. 
In this section we describe how to build such an interface and how the types from GraphIt translate to python types and vice-versa.</p>

<h2 id="graphit-language-extensions">GraphIt language extensions</h2>

<p>The main difference between writing GraphIt programs and writing functions to be called from python is that GraphIt now compiles as a library instead of an executable program. So it doesn’t contain a <code class="highlighter-rouge">main</code> function. Instead users can define any number of custom functions which can be separately invoked from python.</p>

<p>To separate internal helper functions from the function which are exposed as a part of the library, we add the <code class="highlighter-rouge">export</code> keyword. This keyword can be added to any function declaration before the <code class="highlighter-rouge">func</code> keyword. This tells the compiler that this function is supposed to be a part of the library to be called from python and sufficient wrappers should be generated for the same.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export func do_pagerank(edges: edgeset{Edge}, damp: double) -&gt; ranks: vector{Vertex}(float)
  ...
end
</code></pre></div></div>

<p>Notice how unlike the <code class="highlighter-rouge">main</code> function which doesn’t take any arguments, export functions can take arguments for the graph and the required parameters for the algorithm which can be directly passed from the python code.</p>

<h2 id="type-mappings">Type mappings</h2>

<p>The bindings allow user to pass and return python objects over to the GraphIt functions. Python types are translated to GraphIt types and vice-versa using the following mapping. This mapping has been chosen to keep data copy to the minimum to ensure high performance. 
Just like regular python and GraphIt functions, the arguments are passed by reference and any modifications to non scalar types will reflect back in the python program. This feature can also be used if the user wishes to return multiple values.</p>

<h3 id="scalar-types-mappings">Scalar types mappings</h3>

<p>The scalar types in GrapIt directly map to their counterparts in python</p>

<table>
  <thead>
    <tr>
      <th>GraphIt type</th>
      <th>python type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">int</code></td>
      <td><code class="highlighter-rouge">int</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">float</code></td>
      <td><code class="highlighter-rouge">float</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">long</code></td>
      <td><code class="highlighter-rouge">long</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">double</code></td>
      <td><code class="highlighter-rouge">double</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">bool</code></td>
      <td><code class="highlighter-rouge">bool</code></td>
    </tr>
  </tbody>
</table>

<p>GraphIt currently doesn’t have a <code class="highlighter-rouge">string</code> type. Hence <code class="highlighter-rouge">strings</code> cannot be passed or returned at this point.</p>

<h3 id="non-scalar-types-mappings">Non-scalar types mappings</h3>

<p>Following non-scalar types are currently supported as arguments and return values.</p>

<table>
  <thead>
    <tr>
      <th>GraphIt type</th>
      <th>python type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">edgeset{Edge}</code></td>
      <td><code class="highlighter-rouge">scipy.sparse.csr_matrix</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">vector{Veretex}(X)</code></td>
      <td><code class="highlighter-rouge">numpy.array(dtype=X)</code></td>
    </tr>
  </tbody>
</table>

<p>Here <code class="highlighter-rouge">X</code> is any scalar type mapped according to the mappings in the previous section. For the types mentioned in this table, GraphIt guarantees that no data is copied by value.</p>

<h2 id="python-module-api">Python module API</h2>

<p>To fascilate the user to load GraphIt libraries inside python and call into them we provide a module named <code class="highlighter-rouge">graphit</code> that can be imported on installed systems as</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import graphit
</code></pre></div></div>

<p>This module provides mainly the <code class="highlighter-rouge">compile_and_load</code> function which returns a <code class="highlighter-rouge">graphit.graphit_module</code> object. This object has all the functions which are exported from the GraphIt program. 
This function takes in as argument, the path of the GraphIt file to be loaded. The schedule can be either specified in the same file or can be supplied as a optional second argument. 
The function also takes in an optional third argument which is an array of extra arguments to be supplied to the compiler while compiling the generated GraphIt code. This is useful for linking the GraphIt module with third party libraries.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import graphit
pagerank_module = graphit.compile_and_load(algorithm="pagerank.gt", schedule="pagerank_schedule.gt", args=["-lm"])
</code></pre></div></div>

<h3 id="graphitgraphit_module"><code class="highlighter-rouge">graphit.graphit_module</code></h3>

<p>The <code class="highlighter-rouge">graphit.graphit_module</code> type object provides an interface to call into exported GraphIt functions. The functions have the exact same name as it had in the GraphIt file. The arguments follow the same name and order.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from scipy.sparse import csr_matrix
my_graph = load_npz("road-usad.npz")

ranks = pagerank_module.do_pagerank(edges=my_graph, damp=0.85)

</code></pre></div></div>
<p>The ranks which is of type <code class="highlighter-rouge">numpy.array(dtype=float)</code> can now be iterated over and its values used for further processing.</p>


      </section>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/prism.js"></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-79370201-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
